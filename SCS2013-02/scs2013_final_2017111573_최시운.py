# -*- coding: utf-8 -*-
"""SCS2013_Final_2017111573_최시운.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a5J4O4VnZO3fhULICfduKC2F7MIP8T-Y

# SCS2013 Python Programming Final Exam

This is a final exam of SCS2013 Python Programming. Follow the directions and try your best to answer the questions and complete the tasks, using the specific method described if applicable. 

SCS2013 파이썬 프로그래밍 기말고사입니다. 

주어진 설명을 잘 읽고, 만일 구체적인 지시사항이 있다면 그에 따라 과제를 완성하세요. 

과제를 완성한 후, **SCS2013_Final_학번_이름.ipynb**로 파일을 저장한 후 eclass의 과제제출을 통해 제출하세요.

- 문제의 설명과 예상 구현 결과들을 자세히 읽어보고 이해한 후 구현을 시작하세요.
- 문제에서 잘 이해되지 않는 부분이 있다면 질문하시기 바랍니다.

## F-1: String (문자열)

다음과 같은 함수를 완성하세요: `edit_string(my_str, c1, c2)`

- input parameter: `my_str` (string); `c1`, `c2` (서로 다른 1글자 string)
- return: `my_str`에서 `c1`과 `c2` 사이의 문자열을 제거한 문자열을 return

- 만약 `my_str`에 `c1`과 `c2`가 한번도 포함되어 있지 않으면, `False`를 return 
- `my_str`에 `c1`이 2번 이상 포함되어 있으면 integer 0을 return
- `my_str`에 `c1`이 1번 포함되어 있고, `c2`가 `c1`보다 먼저 나타나는 경우 integer 0을 return 
- 그렇지 않은 경우: 즉, `c1`이 1번 포함되어 있고 `c2`보다 먼저 나타나는 경우에는, `c1`과 `c2` 사이의 문자들을 제거한 문자열을 return

**예상되는 결과:**
```
c1 = '('
c2 = ')'

edit_string('SCS2013 (Final) Exam', c1, c2)
>>> 'SCS2013  Exam'

edit_string('SCS2013 (Final) Exam)', c1, c2)
>>> 'SCS2013  Exam)'

edit_string('SCS2013 Final) Exam', c1, c2)
>>> False

edit_string('SCS2013 (Final) (Exam)', c1, c2)
>>> 0

edit_string('SCS2013 Final) (Exam)', c1, c2)
>>> 0
```
"""

# F-1: 
def edit_string(my_str, c1, c2):
  ####### Your code here #######
  firstindex = -1
  secondindex = -1
  for i in range(len(my_str)) :
    if firstindex != -1 and my_str[i] == c1:
      return 0
    if my_str[i] == c1 :
      firstindex = i
    elif my_str[i] == c2:
      secondindex = i
      if firstindex == -1:
        return 0
  return my_str[:firstindex] + my_str[second_index:]
    


  ##############################

"""## F-2: For-loops (반복문)

다음과 같은 함수를 완성하세요: `overwrite_value(list_A, list_B, target)`

- input parameter: `list_A`, `list_B` (같은 개수의 element를 갖는 리스트 list); `target` (string, integer, float, bool 등 아무 type이나 가능)
- 기능: copy each `target` in `list_A` to the corresponding position in `list_B` 
  - 즉, `list_A`의 원소 값들 중 `target`과 일치하는 경우, `target` 값을 `list_B`의 해당 위치에 복사
- return: return은 없으나, `list_A`의 값은 변하지 않고 `list_B`의 값은 변할 수 있음

**예상되는 결과:**
```
list_A = ['m','o','o',1]
list_B = [1,2,3,4]

print(f'list A: {list_A}, list B: {list_B}')

overwrite_value(list_A, list_B, 'o')

print(f'list A: {list_A}, list B: {list_B}')

>>> list A: ['m', 'o', 'o', 1], list B: [1, 2, 3, 4]
    list A: ['m', 'o', 'o', 1], list B: [1, 'o', 'o', 4]
```
- 이와 같이 `target`이 소문자 'o'일때, `list_A`에서 소문자 'o'가 2,3번째 값에 위치하므로, `list_B`의 2,3번째 원소값들을 소문자 'o'로 바꿈
"""

# F-2: 
def overwrite_value(list_A, list_B, target):
  ####### Your code here #######
  index = []
  content = []
  contentindex = 0
  for i in range(len(list_A)):
    if list_A[i] == target:
      list_B[i] = target

  

  ##############################

list_A = ['m','o','o',1]
list_B = [1,2,3,4]

print(f'list A: {list_A}, list B: {list_B}')

overwrite_value(list_A, list_B, 'o')

print(f'list A: {list_A}, list B: {list_B}')

"""## F-3: List Comprehension (리스트)

**list comprehension**을 사용하여 다음과 같은 리스트 (list)를 생성하세요.

- 주어진 list `fruits`는 `('fruit_name', 'fruit_price', 'fruit_numbers')` tuple을 각 element로 가짐
  - `fruit_name`: 과일 이름 
  - `fruit_price`: 과일 1개 당 가격
  - `fruit_numbers`: 과일 개수


- (1) `fruit_names`: `fruits`에서 `fruit_name`만 모아서 이를 element로 하는 list `fruit_names`를 생성하세요. 
  - 과일 이름은 모두 *소문자*로 변환하세요

- (2) `fruit_total_prices`: `fruits`에서 각 과일의 총 가격 (과일 1개당 가격 x 과일 개수) 을 element로 가지는 list `fruit_total_prices`를 생성하세요.

- (3) `fruit_low_prices`: `fruits`에서 가격이 10 이하인 과일들을 모아 해당 과일의 `fruit_name`을 element로 하는 list `fruit_low_prices`를 생성하세요. 
  - 과일 이름은 모두 *대문자*로 변환하세요

**예상되는 결과:**
```
fruits = [('banana', 45, 6), ('apple', 10, 15), ('kiwi', 7, 10)]

>>> fruit_names = ['banana', 'apple', 'kiwi']
    fruit_total_prices = [270, 150, 70]
    fruit_low_prices = ['APPLE', 'KIWI']
```


"""

fruits = [('banana', 45, 6), ('apple', 10, 15), ('kiwi', 7, 10)]

# F-3: 
####### Your code here #######
fruit_names = [ values.lower() for value in fruits for values in value if type(values) is str]
print(f"fruit_names = {fruit_names}")

fruit_total_prices = [ value[1]*value[2] for value in fruits ]
print(f"fruit_total_prices = {fruit_total_prices}")

fruit_low_prices = [ value[0].upper() for value in fruits if value[1]<=10]
print(f"fruit_low_prices = {fruit_low_prices}")


##############################

"""## F-4: Recursion (재귀)

**Recursion (재귀)**를 사용하여 다음과 같은 함수를 완성하세요: `countdown(count_start, count_by)`

- input parameter: `count_start` (integer), `count_by` (integer)
- 기능: `count_start`에서부터 시작해서 `count_by`씩 줄어들면서 음수가 되기 전까지 카운트다운을 출력 (print)함
- return: return은 없으나 카운트다운을 출력 (print) 해야 함


**예상되는 결과:**
```
count_start = 10
count_by = 2

countdown(count_start, count_by)
>>> Count down: 10
    Count down: 8
    Count down: 6
    Count down: 4
    Count down: 2
    Count down: 0
```

"""

# F-4: 
def countdown(count_start, count_by):
  ####### Your code here #######
    count_num = count_start
    if count_num < 0:
        pass
    else:
        print(f"Count down: {count_num}")
        countdown(count_num -count_by, count_by)

"""## F-5: File I/O (파일 입출력)

**파일 입출력 (File I/O)**를 사용하여 다음과 같은 함수를 완성하세요: `word_freq(filename)`

- input parameter: `filename` (파일이름 string)
- 기능: `filename` 파일 내에 있는 텍스트들에 포함되어 있는 단어들을 확인하고, 각 단어가 포함된 횟수를 카운트. 각 단어와 횟수를 (key, value)로 하는 **dictionary** `word_counts`를 생성
  - 단어는 대/소문자 구분 없이 모두 *소문자*로 변환하여 생각할 것 
  
- return: dictionary인 `word_counts`를 return

**예상되는 결과:**
```
# word_freq.txt
Happy Christmas
Merry Christmas
Happy New Year

word_freq('word_freq.txt')
>>> {'christmas': 2, 'happy': 2, 'merry': 1, 'new': 1, 'year': 1}
```
- 동작을 테스트할 참고용 파일인 'word_freq.txt'는 eclass 과제란에 같이 제공되어 있음
"""

# F-5: 
def word_freq(filename):
  ####### Your code here #######
  filename = filename.lower()
  words = filename.split(' ')
  
  word_counts = {}
  for i in words :
    if not i in word_counts:
      word_counts[i] = 1
    else :
      word_counts[i] += 1 

  return word_counts

  ##############################

"""## F-6: Class (클래스)

다음의 **Class (클래스)** 구조 `Course`를 완성하세요: 

- 생성자 (constructor): 다음의 instance variable을 초기화
  - `course_num`: 교과목에 해당하는 string, e.g., 'SCS2013'
  - `pre_courses`: list이며, 아무 값도 입력되지 않는 경우 empty list를 설정

- instance method `get_all_pre_courses()`: 이 과목의 선수과목의 과목명 `course_num`을 모두 모아 list를 생성하여 이를 return
  - 이 과목의 선수과목에 포함된 선수과목들을 모두 포함해야 함
  - 따라서 *recursion (재귀)*를 사용함
  - 선수과목이 하나도 없다면 empty list를 return 
  - hint: `lista + listb`를 통해 두개의 리스트의 원소들을 하나로 합칠 수 있음 


**예상되는 결과:**
```
c1 = Course('SCS110', [])
c2 = Course('SCS210', [c1])
c3 = Course('SCS280', [c1])
c4 = Course('SCS450', [c2, c3])

print(f'c1 precourses: {c1.get_all_pre_courses()}')
print(f'c2 precourses: {c2.get_all_pre_courses()}')
print(f'c3 precourses: {c3.get_all_pre_courses()}')
print(f'c4 precourses: {c4.get_all_pre_courses()}')
>>> c1 precourses: []
    c2 precourses: ['SCS110']
    c3 precourses: ['SCS110']
    c4 precourses: ['SCS210', 'SCS110', 'SCS280', 'SCS110']
```
"""

# F-6: 
class Course():
  ####### Your code here: constructor #######
    def __init__(self, course_num, pre_courses=[]):
        self.course_num = course_num
        self.pre_courses = pre_courses


  ##############################

  ####### Your code here: get_all_pre_courses #######
    def get_all_pre_courses(self):
        fist_precourses = []
        second_precourse = []
        for course in self.pre_courses:
            first_precourses.append(course.course_num)
            second_precourses = course.get_all_pre_courses()
            first_precourses += second_precourses
        return all_precourses
            

  ##############################
  
    def is_required(self, target_course_num):
        if target_course_num in self.get_all_pre_courses():
            return True
        else:
            return False

"""## F-7: Class Inheritance (상속)

**Class Inheritance (클래스 상속)**을 사용하여 parent 클래스 `Account`와, 이를 상속받는 두 child 클래스 `CheckAccount`, `SavingAccount`를 완성하세요. 

*parent class `Account`*:     
- 생성자: instance variable 초기화
  - `holder_name`: 계좌 이름
  - `balance`: 계좌 잔고 
  - 아무 값도 입력되지 않는다면, `balance`의 초기값은 0으로 설정
- `deposit(amount)`
  - `amount`만큼의 돈을 계좌 잔고에 입금하고 balance를 return 
- `withdraw(amount)`
  - `amount`만큼의 돈을 계좌 잔고에서 출금하고 balance를 return 
  - 만일 잔고가 부족하다면 메시지를 출력: e.g., "balance is not enough!"
- `transfer(amount, new_account)`
  - `amount`만큼의 돈을 다른 계좌 `new_account`로 송금함
  - 송금은 현 계좌에서 `amount`를 `withdraw`하고, `new_account`에서는 `amount`를 `deposit`함으로써 이루어짐
- `print_info()`: 계좌 정보를 출력


"""

# F-7-1:
class Account():
  ####### Your code here: constructor #######
    def __init__(self, holder_name, balance=0):
        self.holder_name = holder_name
        self.balance = balance

  ##############################

  ####### Your code here: deposit #######

    def deposit(self, amount):
        self.balance += amount
        return self.balance

  ##############################
  
  ####### Your code here: withdraw #######
    
    def withdraw(self, amount):
        self.balance -= amount
        return self.balance 

  ##############################

    def transfer(self, amount, new_account):
        self.withdraw(amount)
        new_account.deposit(amount)

    def print_info(self):
        print(f'Account {self.holder_name}: balance {round(self.balance,2)}')

"""*child class `CheckAccount`*:  
- `Account`를 상속   
- 생성자: instance variable 초기화
  - parent class `Account`의 생성자 호출 
  - 추가 instance variable인 `w_fee` (인출 수수료 integer)를 초기화 
  - 아무 값도 입력되지 않는다면, `w_fee`의 초기값은 10으로 설정

- `withdraw(amount)`
  - overriding method임 
  - 인출 수수료 `w_fee`가 **추가**로 인출되어야 함 

- `print_info()`: 계좌 정보를 출력


"""

# F-7-2:
class CheckAccount(Account):
  ####### Your code here: constructor #######
    def __init__(self, holder_name, balance, w_fee=10):
        super().__init__(holder_name, balance)
        self.w_fee = w_fee

  ##############################

  ####### Your code here: withdraw #######
    def withdraw(self, amount):
        self.balance -= (self.w_fee + amount)
        return self.balance

  ##############################

    def print_info(self):
        print(f'CheckAccount {self.holder_name}: balance {round(self.balance,2)}, withdraw fee {self.w_fee}')

"""*child class `SavingAccount`*:     
- `Account`를 상속
- 생성자: instance variable 초기화
  - parent class `Account`의 생성자 호출 
  - 추가 instance variable인 `rate` (예금이자 float)와 `d_fee` (입금 수수료 integer)를 초기화
  - 아무 값도 입력되지 않는다면, `rate` 의 초기값은 0.02, `d_fee`의 초기값은 5로 설정 

- `deposit(amount)`
  - overriding method임 
  - 입금 수수료 `d_fee`를 뺀 금액만큼 입금되어야 함

- `interest()`:     
  - 계좌 잔고에 해당하는 금리만큼 예금이자를 계산 
  - 예금이자 `rate` (float)는 금리 \% 값으로, 0.02인 경우 2\%만큼 이자를 계산하여 계좌 잔고 `balance`가 증가되어야 함 
  - `balance`를 return: `round(self.balance, 2)`로 return하면 소수점 2자리로 표현 가능함 

- `print_info()`: 계좌 정보를 출력


"""

# F-7-3:
class SavingAccount(Account):
  ####### Your code here: constructor #######
    def __init__(self, holder_name, balance, rate = 0.02, d_fee = 5):
        super().__init__(holder_name, balance)
        self.rate = rate
        self.d_fee = d_fee

  ####### Your code here: deposit #######
    def deposit(self, amount):
        self.balance += (amount - self.d_fee)
        return self.balance

 

  ####### Your code here: interest #######
    def interest(self):
        interest = self.balance * self.rate
        self.balance += interest
        return round(self.balance, 2)

  ##############################
    def print_info(self):
        print(f'SavingAccount {self.holder_name}: balance {round(self.balance,2)}, interest rate {self.rate}, deposit fee {self.d_fee}')

"""**예상되는 결과**:     

- `Account`, `CheckAccount`, `SavingAccount` 생성 결과:
```
acc_a = Account('A', 500)
acc_b = CheckAccount('B', 300)
acc_c = SavingAccount('C', 350, rate=0.1)
acc_a.print_info()
acc_b.print_info()
acc_c.print_info()
>>> Account A: balance 500
    CheckAccount B: balance 300, withdraw fee 10
    SavingAccount C: balance 350, interest rate 0.1, deposit fee 5
```

- `transfer` 함수의 동작 결과: `Account` 에서 `CheckAccount`로 송금:
```
acc_a.transfer(80, acc_b)
acc_a.print_info()
acc_b.print_info()
>>> Account A: balance 420
    CheckAccount B: balance 380, withdraw fee 10
```

- `CheckAccount` 의 `withdraw` 함수 동작 결과:
```
acc_b.withdraw(50)
acc_b.print_info()
>>> CheckAccount B: balance 320, withdraw fee 10
```

- `SavingAccount` 의 `deposit`, `interest` 함수 동작 결과:
```
acc_c.deposit(50)
acc_c.print_info()
acc_c.interest()
acc_c.print_info()
>>> SavingAccount C: balance 395, interest rate 0.1, deposit fee 5
    SavingAccount C: balance 434.5, interest rate 0.1, deposit fee 5
```

## F-8: Regular Expressions (정규표현식)

**regular expression (정규표현식)**을 사용하여 다음의 함수를 구현하세요: `file_re(filename)`

- input parameter: `filename` (파일이름 string)
- 기능: `filename` 파일 내에 있는 텍스트를 읽어들여 다음의 두가지 정규표현식을 수행함 
  - (1) 모든 multiple whitespaces (공백문자)를 single whitespace (단일 공백문자: 띄어쓰기) 로 바꾸기 
  - (2) 'P' 혹은 'p'로 시작하고, 'n' 혹은 'g'로 끝나는 모든 단어들을 찾기 - 중복은 고려하지 않음
  - 찾아낸 list를 return 
 
- return: 찾아낸 단어들을 모은 list를 return 


**예상되는 결과:**
```
# file_re.txt
Python        programming 
is a   programming language
Python   is fun
Start to   have a   fun  

file_re('file_re.txt')
>>> ['Python', 'programming', 'programming', 'Python']
```
- 동작을 테스트할 참고용 파일인 'file_re.txt'는 eclass 과제란에 같이 제공되어 있음
"""

import re
import numpy as np

# F-8: 
def file_re(filename):

  ####### Your code here #######
  pattern = r'\s+'
  replace = ' '
  new_str = re.sub(pattern, replace, my_str)
  print(my_str)
  print(new_str)

  pattern2 = r'\b[P|p]\w*[n|g]\b'
  result = re.findall(pattern2, new_str)
  return result

  ##############################

"""## F-9: NumPy (넘파이)

**NumPy**을 사용하여 다음의 함수들을 구현하세요: 

- `create_rand_arr(n)`
  - input parameter: `n` (integer)
  - 기능: $1$부터 $20 \times n$ 사이의 정수들 중에서 랜덤한 정수들을 $2n^2$개 만큼 생성하여 $n \times 2n$ 크기의 `ndarray`를 생성하여 return 

- `compute_subarr(arr, n)`
  - input parameter: `arr` (ndarray), `n` (integer)
  - 기능: `arr`의 column들 중에서 첫번째 column부터 `n`씩 건너뛰면서 선택하여 subarray를 만들고, 각 row마다 (즉, column 요소들에 대해 체크하면서) 최소, 최대값을 계산하여 (`sub_min`, `sub_max`) tuple을 return 

**예상되는 결과 (랜덤이기 때문에 숫자는 다를 수 있음):**
```
arr = create_rand_arr(3)
arr
>>> array([[29, 41, 39, 42, 57, 12],
       [ 1, 48, 58, 24, 54, 51],
       [ 5, 54, 34, 15,  7, 30]])

sub_min, sub_max = compute_subarr(arr, 4)
print(f'Min: {sub_min}')
print(f'Max: {sub_max}')
>>> Min: [29  1  5]
    Max: [57 54  7]
```
"""

# F-9-1: 
def create_rand_arr(n):
  ####### Your code here #######
  ndarray = np.random.randint(1,20*n+1,(n,2*n))
  return ndarray

  ##############################

# F-9-2: 

def compute_subarr(arr, n):
  ####### Your code here #######
  subarray = arr[::1, 0::n]
  return subarray

  ##############################